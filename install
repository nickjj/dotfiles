#!/usr/bin/env bash
# Install these dotfiles, run: ./install --help for help and examples.

set -o errexit

BOOTSTRAP_PATH="/tmp/nickjj-dotfiles"
DOTFILES_PATH="${DOTFILES_PATH:-}"

if [ -f "${DOTFILES_PATH}/install-config" ]; then
  # shellcheck disable=SC1091
  . "${DOTFILES_PATH}/install-config"
elif [ -f "${BOOTSTRAP_PATH}/install-config" ]; then
  # shellcheck disable=SC1091
  . "${BOOTSTRAP_PATH}/install-config"
else
  # This happens on a first run that's not bootstrapped which is typically
  # the case when running tests in a container.

  # shellcheck disable=SC1091
  [ -f ./install-config ] && . ./install-config
fi

# Only run these when calling the script, not sourcing it.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Instead of cloning from a remote repo, files will get copied locally. This
  # is useful for testing in a container without committing anything.
  LOCAL="${LOCAL:-}"

  # This will get optionally populated later, it essentially does a git pull
  # to pull in the latest changes locally.
  PULL=

  # This will get optionally populated later, it combines pulling in the latest
  # updates and running the install script.
  PULL_UPDATE=

  # This will get optionally populated later.
  SKIP_SYSTEM_PACKAGES=

  DOTFILES_REPO_SLUG="${DOTFILES_REPO_SLUG:-}"
  DOTFILES_CLONE_URL="${DOTFILES_CLONE_URL:-}"
  DOTFILES_UPSTREAM_URL="${DOTFILES_UPSTREAM_URL:-}"
  DOTFILES_BRANCH="${DOTFILES_BRANCH:-}"

  YOUR_NAME="${YOUR_NAME:-}"
  YOUR_EMAIL="${YOUR_EMAIL:-}"

  # Is the variable defined as an array or string? -z doesn't reliably work
  # on arrays since it only looks at the first element.
  if [[ "${PACKAGES_PACMAN+x}" ]]; then
    # If the variable is defined with an empty value, the intent is to
    # override the defaults with nothing.
    [ -z "${PACKAGES_PACMAN}" ] && PACKAGES_PACMAN=()
  else
    # The exported variable is commented out, fallback to defaults.
    PACKAGES_PACMAN=(
      "aspell"
      "base"
      "base-devel"
      "bat"
      "bc"
      "btop"
      "curl"
      "dnsutils"
      "eza"
      "fastfetch"
      "fd"
      "ffmpeg"
      "fontconfig"
      "fzf"
      "git"
      "git-delta"
      "gnupg"
      "go-yq"
      "imagemagick"
      "inotify-tools"
      "jq"
      "less"
      "libqalculate"
      "man-db"
      "man-pages"
      "mise"
      "neovim"
      "openbsd-netcat"
      "openssh"
      "pacman-contrib"
      "pwgen"
      "ripgrep"
      "rsync"
      "shellcheck"
      "shfmt"
      "smartmontools"
      "tmux"
      "unzip"
      "usbutils"
      "wev"
      "wget"
      "whois"
      "wl-clipboard"
      "zip"
      "zsh"
    )
  fi

  if [[ "${PACKAGES_PACMAN_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_PACMAN_EXTRAS}" ] && PACKAGES_PACMAN_EXTRAS=()
  else
    PACKAGES_PACMAN_EXTRAS=()
  fi

  if [[ "${PACKAGES_PACMAN_GUI+x}" ]]; then
    [ -z "${PACKAGES_PACMAN_GUI}" ] && PACKAGES_PACMAN_GUI=()
  else
    PACKAGES_PACMAN_GUI=(
      "brightnessctl"
      "docker"
      "docker-buildx"
      "docker-compose"
      "ffmpegthumbnailer"
      "firefox"
      "ghostty"
      "gimp"
      "grim"
      "hyprpicker"
      "kdenlive"
      "keepassxc"
      "libqalculate"
      "libreoffice"
      "mako"
      "mpd"
      "mpd-mpris"
      "mpv"
      "niri"
      "noto-fonts-emoji"
      "obs-studio"
      "pipewire"
      "pipewire-alsa"
      "pipewire-jack"
      "pipewire-pulse"
      "rmpc"
      "satty"
      "slurp"
      "swaybg"
      "swayidle"
      "swaylock"
      "thunar"
      "thunar-archive-plugin"
      "timidity++"
      "ttf-freefont"
      "tumbler"
      "uwsm"
      "waybar"
      "wiremix"
      "wireplumber"
      "xarchiver"
      "xdg-desktop-portal-gnome"
      "xdg-desktop-portal-gtk"
      "xwayland-satellite"
    )
  fi

  if [[ "${PACKAGES_PACMAN_GUI_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_PACMAN_GUI_EXTRAS}" ] && PACKAGES_PACMAN_GUI_EXTRAS=()
  else
    PACKAGES_PACMAN_GUI_EXTRAS=()
  fi

  if [[ "${PACKAGES_AUR+x}" ]]; then
    [ -z "${PACKAGES_AUR}" ] && PACKAGES_AUR=()
  else
    PACKAGES_AUR=()
  fi

  if [[ "${PACKAGES_AUR_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_AUR_EXTRAS}" ] && PACKAGES_AUR_EXTRAS=()
  else
    PACKAGES_AUR_EXTRAS=()
  fi

  if [[ "${PACKAGES_AUR_GUI+x}" ]]; then
    [ -z "${PACKAGES_AUR_GUI}" ] && PACKAGES_AUR_GUI=()
  else
    PACKAGES_AUR_GUI=(
      "elephant-bin"
      "elephant-calc-bin"
      "elephant-clipboard-bin"
      "elephant-desktopapplications-bin"
      "elephant-files-bin"
      "elephant-menus-bin"
      "elephant-providerlist-bin"
      "elephant-runner-bin"
      "elephant-symbols-bin"
      "elephant-unicode-bin"
      "elephant-websearch-bin"
      "elephant-windows-bin"
      "walker-bin"
      "wlrctl"
      "xnviewmp"
    )
  fi

  if [[ "${PACKAGES_AUR_GUI_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_AUR_GUI_EXTRAS}" ] && PACKAGES_AUR_GUI_EXTRAS=()
  else
    PACKAGES_AUR_GUI_EXTRAS=()
  fi

  if [[ "${PACKAGES_APT+x}" ]]; then
    [ -z "${PACKAGES_APT}" ] && PACKAGES_APT=()
  else
    PACKAGES_APT=(
      "aspell"
      "bat"
      "bc"
      "dnsutils"
      "btop"
      "build-essential"
      "curl"
      "ffmpeg"
      "fontconfig"
      "git"
      "gnupg"
      "imagemagick"
      "inotify-tools"
      "iproute2"
      "keepassxc"
      "netcat-openbsd"
      "openssh-server"
      "pwgen"
      "qalc"
      "rsync"
      "smartmontools"
      "tmux"
      "unzip"
      "usbutils"
      "wev"
      "wget"
      "whois"
      "wl-clipboard"
      "xz-utils"
      "zip"
      "zsh"
    )
  fi

  if [[ "${PACKAGES_APT_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_APT_EXTRAS}" ] && PACKAGES_APT_EXTRAS=()
  else
    PACKAGES_APT_EXTRAS=()
  fi

  if [[ "${PACKAGES_BREW+x}" ]]; then
    [ -z "${PACKAGES_BREW}" ] && PACKAGES_BREW=()
  else
    PACKAGES_BREW=(
      "aspell"
      "bash"
      "bat"
      "bc"
      "btop"
      "curl"
      "diffutils"
      "eza"
      "fastfetch"
      "fd"
      "ffmpeg"
      "fzf"
      "git"
      "git-delta"
      "gnupg"
      "imagemagick"
      "jq"
      "libqalculate"
      "mise"
      "nvim"
      "pwgen"
      "ripgrep"
      "rsync"
      "shellcheck"
      "shfmt"
      "smartmontools"
      "tmux"
      "usbutils"
      "wget"
      "xz"
      "yq"
      "zsh"
    )
  fi

  if [[ "${PACKAGES_BREW_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_BREW_EXTRAS}" ] && PACKAGES_BREW_EXTRAS=()
  else
    PACKAGES_BREW_EXTRAS=()
  fi

  if [[ "${PACKAGES_BREW_CASK+x}" ]]; then
    [ -z "${PACKAGES_BREW_CASK}" ] && PACKAGES_BREW_CASK=()
  else
    PACKAGES_BREW_CASK=(
      "firefox"
      "ghostty"
      "gimp"
      "google-chrome"
      "keepassxc"
      "key-codes"
      "maccy"
    )
  fi

  if [[ "${PACKAGES_BREW_CASK_EXTRAS+x}" ]]; then
    [ -z "${PACKAGES_BREW_CASK_EXTRAS}" ] && PACKAGES_BREW_CASK_EXTRAS=()
  else
    PACKAGES_BREW_CASK_EXTRAS=()
  fi

  if [[ "${MISE_ARCH+x}" ]]; then
    [ -z "${MISE_ARCH}" ] && MISE_ARCH=()
  else
    MISE_ARCH=()
  fi

  if [[ "${MISE_ARCH_EXTRAS+x}" ]]; then
    [ -z "${MISE_ARCH_EXTRAS}" ] && MISE_ARCH_EXTRAS=()
  else
    MISE_ARCH_EXTRAS=()
  fi

  if [[ "${MISE_DEBIAN+x}" ]]; then
    [ -z "${MISE_DEBIAN}" ] && MISE_DEBIAN=()
  else
    MISE_DEBIAN=(
      "eza"
      "fd"
      "fzf"
      "jq"
      "neovim"
      "ripgrep"
      "shellcheck"
      "shfmt"
      "yq"
    )
  fi

  if [[ "${MISE_DEBIAN_EXTRAS+x}" ]]; then
    [ -z "${MISE_DEBIAN_EXTRAS}" ] && MISE_DEBIAN_EXTRAS=()
  else
    MISE_DEBIAN_EXTRAS=()
  fi

  if [[ "${MISE_MACOS+x}" ]]; then
    [ -z "${MISE_MACOS}" ] && MISE_MACOS=()
  else
    MISE_MACOS=()
  fi

  if [[ "${MISE_MACOS_EXTRAS+x}" ]]; then
    [ -z "${MISE_MACOS_EXTRAS}" ] && MISE_MACOS_EXTRAS=()
  else
    MISE_MACOS_EXTRAS=()
  fi

  if [[ ! "${MISE_LANGUAGES+x}" ]]; then
    declare -A MISE_LANGUAGES
    MISE_LANGUAGES["node"]="node@24.11"
    MISE_LANGUAGES["python"]="python@3.14"
  fi

  if [[ ! "${MISE_LANGUAGES_EXTRAS+x}" ]]; then
    declare -A MISE_LANGUAGES_EXTRAS
  fi

  if [[ "${CONFIG_INSTALL+x}" ]]; then
    [ -z "${CONFIG_INSTALL}" ] && CONFIG_INSTALL=()
  else
    CONFIG_INSTALL=(
      "ln -fns \"\${DOTFILES_PATH}/.config/bat/config\" \"\${XDG_CONFIG_HOME}/bat/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/btop/btop.conf\" \"\${XDG_CONFIG_HOME}/btop/btop.conf\""
      "ln -fns \"\${DOTFILES_PATH}/.config/fzf/config.sh\" \"\${XDG_CONFIG_HOME}/fzf/config.sh\""
      "ln -fns \"\${DOTFILES_PATH}/.config/ghostty/config.local\" \"\${XDG_CONFIG_HOME}/ghostty/config.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/ghostty/config\" \"\${XDG_CONFIG_HOME}/ghostty/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/git/config.local\" \"\${XDG_CONFIG_HOME}/git/config.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/git/config\" \"\${XDG_CONFIG_HOME}/git/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/nvim\" \"\${XDG_CONFIG_HOME}/nvim\""
      "ln -fns \"\${DOTFILES_PATH}/.config/tmux/tmux.conf\" \"\${XDG_CONFIG_HOME}/tmux/tmux.conf\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.aliases.local\" \"\${XDG_CONFIG_HOME}/zsh/.aliases.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.aliases\" \"\${XDG_CONFIG_HOME}/zsh/.aliases\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.xdg.local\" \"\${XDG_CONFIG_HOME}/zsh/.xdg.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.zprofile.local\" \"\${XDG_CONFIG_HOME}/zsh/.zprofile.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.zprofile\" \"\${XDG_CONFIG_HOME}/zsh/.zprofile\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.zshenv\" \"\${HOME}/.zshenv\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.zshrc.local\" \"\${XDG_CONFIG_HOME}/zsh/.zshrc.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/zsh/.zshrc\" \"\${XDG_CONFIG_HOME}/zsh/.zshrc\""
      "ln -fns \"\${DOTFILES_PATH}/.local/bin/\"* \"\${HOME}/.local/bin/\""
    )
  fi

  if [[ "${CONFIG_INSTALL_EXTRAS+x}" ]]; then
    [ -z "${CONFIG_INSTALL_EXTRAS}" ] && CONFIG_INSTALL_EXTRAS=()
  else
    CONFIG_INSTALL_EXTRAS=()
  fi

  if [[ "${CONFIG_INSTALL_GUI_LINUX+x}" ]]; then
    [ -z "${CONFIG_INSTALL_GUI_LINUX}" ] && CONFIG_INSTALL_GUI_LINUX=()
  else
    CONFIG_INSTALL_GUI_LINUX=(
      "ln -fns \"\${DOTFILES_PATH}/.config/elephant\" \"\${XDG_CONFIG_HOME}/elephant\""
      "ln -fns \"\${DOTFILES_PATH}/.config/fontconfig/fonts.conf\" \"\${XDG_CONFIG_HOME}/fontconfig/fonts.conf\""
      "ln -fns \"\${DOTFILES_PATH}/.config/mako/config.local\" \"\${XDG_CONFIG_HOME}/mako/config.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/mako/config\" \"\${XDG_CONFIG_HOME}/mako/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/mpd/mpd.conf\" \"\${XDG_CONFIG_HOME}/mpd/mpd.conf\""
      "ln -fns \"\${DOTFILES_PATH}/.config/niri/config.kdl.local\" \"\${XDG_CONFIG_HOME}/niri/config.kdl.local\""
      "ln -fns \"\${DOTFILES_PATH}/.config/niri/config.kdl\" \"\${XDG_CONFIG_HOME}/niri/config.kdl\""
      "ln -fns \"\${DOTFILES_PATH}/.config/rmpc/config.ron\" \"\${XDG_CONFIG_HOME}/rmpc/config.ron\""
      "ln -fns \"\${DOTFILES_PATH}/.config/satty/config.toml\" \"\${XDG_CONFIG_HOME}/satty/config.toml\""
      "ln -fns \"\${DOTFILES_PATH}/.config/swayidle/config\" \"\${XDG_CONFIG_HOME}/swayidle/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/swaylock/config\" \"\${XDG_CONFIG_HOME}/swaylock/config\""
      "ln -fns \"\${DOTFILES_PATH}/.config/tumbler/tumbler.rc\" \"\${XDG_CONFIG_HOME}/tumbler/tumbler.rc\""
      "ln -fns \"\${DOTFILES_PATH}/.config/uwsm/env\" \"\${XDG_CONFIG_HOME}/uwsm/env\""
      "ln -fns \"\${DOTFILES_PATH}/.config/walker/config.toml\" \"\${XDG_CONFIG_HOME}/walker/config.toml\""
      "ln -fns \"\${DOTFILES_PATH}/.config/walker/themes/base/style.css\" \"\${XDG_CONFIG_HOME}/walker/themes/base/style.css\""
      "ln -fns \"\${DOTFILES_PATH}/.config/waybar/config.jsonc\" \"\${XDG_CONFIG_HOME}/waybar/config.jsonc\""
      "ln -fns \"\${DOTFILES_PATH}/.config/waybar/style.css\" \"\${XDG_CONFIG_HOME}/waybar/style.css\""
      "ln -fns \"\${DOTFILES_PATH}/.local/share/applications/\"* \"\${XDG_DATA_HOME}/applications/\""
    )
  fi

  if [[ "${CONFIG_INSTALL_GUI_LINUX_EXTRAS+x}" ]]; then
    [ -z "${CONFIG_INSTALL_GUI_LINUX_EXTRAS}" ] && CONFIG_INSTALL_GUI_LINUX_EXTRAS=()
  else
    CONFIG_INSTALL_GUI_LINUX_EXTRAS=(
      "ln -fns \"/data/storage/docs\" \"${HOME}/docs\""
      "ln -fns \"/data/storage/downloads\" \"${HOME}/downloads\""
      "ln -fns \"/data/storage/media\" \"${HOME}/media\""
      "ln -fns \"/data/storage/tmp\" \"${HOME}/tmp\""
    )
  fi

  if [[ "${CONFIG_INSTALL_ARCH+x}" ]]; then
    [ -z "${CONFIG_INSTALL_ARCH}" ] && CONFIG_INSTALL_ARCH=()
  else
    CONFIG_INSTALL_ARCH=(
      "sudo ln -fns \"\${DOTFILES_PATH}/etc/pacman.d/01-options.conf\" \"/etc/pacman.d/01-options.conf\""
      "sudo ln -fns \"/run/systemd/resolve/stub-resolv.conf\" \"/etc/resolv.conf\""
    )
  fi

  if [[ "${CONFIG_INSTALL_ARCH_EXTRAS+x}" ]]; then
    [ -z "${CONFIG_INSTALL_ARCH_EXTRAS}" ] && CONFIG_INSTALL_ARCH_EXTRAS=()
  else
    CONFIG_INSTALL_ARCH_EXTRAS=()
  fi

  if [[ "${CONFIG_INSTALL_WSL+x}" ]]; then
    [ -z "${CONFIG_INSTALL_WSL}" ] && CONFIG_INSTALL_WSL=()
  else
    CONFIG_INSTALL_WSL=(
      "cp \"\${DOTFILES_PATH}/mnt/c/Users/Nick/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json\" \"/mnt/c/Users/%WindowsUser/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json\" || true"
      "sudo ln -fns \"\${DOTFILES_PATH}/etc/wsl.conf\" \"/etc/wsl.conf\""
    )
  fi

  if [[ "${CONFIG_INSTALL_WSL_EXTRAS+x}" ]]; then
    [ -z "${CONFIG_INSTALL_WSL_EXTRAS}" ] && CONFIG_INSTALL_WSL_EXTRAS=()
  else
    CONFIG_INSTALL_WSL_EXTRAS=()
  fi

  if [[ ! "${SUDOERS_ENTRIES+x}" ]]; then
    declare -A SUDOERS_ENTRIES
    SUDOERS_ENTRIES["dot-timedatectl"]="${USER} ALL=(ALL) NOPASSWD: /usr/bin/timedatectl"
  fi

  if [[ ! "${SUDOERS_ENTRIES_EXTRAS+x}" ]]; then
    declare -A SUDOERS_ENTRIES_EXTRAS
  fi

  if [[ "${SYSTEMD_ENABLED_SERVICES+x}" ]]; then
    [ -z "${SYSTEMD_ENABLED_SERVICES}" ] && SYSTEMD_ENABLED_SERVICES=()
  else
    SYSTEMD_ENABLED_SERVICES=(
      "docker"
    )
  fi

  if [[ "${SYSTEMD_ENABLED_SERVICES_EXTRAS+x}" ]]; then
    [ -z "${SYSTEMD_ENABLED_SERVICES_EXTRAS}" ] && SYSTEMD_ENABLED_SERVICES_EXTRAS=()
  else
    SYSTEMD_ENABLED_SERVICES_EXTRAS=()
  fi
fi

# We always want to determine these values no matter how this script is called.
CPU_ARCH="$(uname -m)"
OS_TYPE="$(uname | tr "[:upper:]" "[:lower:]")"
OS_DISTRO=
OS_IN_WSL=

C_RED="\e[0;31;1m"
C_GREEN="\e[0;32;1m"
C_CYAN="\e[0;36;1m"
C_RESET="\e[0m"

# Do we want GUI support? GUI_ENABLED will get set based on multiple conditions.
GUI_LINUX="${GUI_LINUX:-}"
GUI_ENABLED=

# Are we in a container?
IN_CONTAINER="${IN_CONTAINER:-}"

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

_error() {
  local message="${1:-}"

  printf "%bERROR: %s%b\n\n" "${C_RED}" "${message}" "${C_RESET}" >&2
  exit 1
}

_info() {
  local message="${1:-}"
  printf "\n\n%b%s:%b\n\n" "${C_CYAN}" "${message}" "${C_RESET}"
}

_local_clone() {
  [ "${LOCAL}" != "1" ] && return 1

  # Extra protection to avoid clobbering real real dotfiles.
  if [ "${PWD}" != "${DOTFILES_PATH}" ]; then
    cp -R "${PWD}/." "${DOTFILES_PATH}"

    # Ensure the containerized environment starts fresh.
    if [ "${IN_CONTAINER}" == "1" ]; then
      rm \
        "${DOTFILES_PATH}/.config/ghostty/config.local" \
        "${DOTFILES_PATH}/.config/git/config.local" \
        "${DOTFILES_PATH}/.config/mako/config.local" \
        "${DOTFILES_PATH}/.config/niri/config.kdl.local" \
        "${DOTFILES_PATH}/.config/zsh/.aliases.local" \
        "${DOTFILES_PATH}/.config/zsh/.zprofile.local" \
        "${DOTFILES_PATH}/.config/zsh/.zsh_history" \
        "${DOTFILES_PATH}/.config/zsh/.zshrc.local"

      if grep -q "git@github.com:" "${DOTFILES_PATH}/.git/config"; then
        sed -i "s|git@github.com:|https://github.com/|g" "${DOTFILES_PATH}/.git/config"
      fi
    fi
  fi

  printf "They've been locally copied to '%s'\n" "${DOTFILES_PATH}"
}

_no_system_packages() {
  cat <<EOF
System package installation isn't supported with your distro (${OS_DISTRO})

Please install any comparable packages on your own, you can view the list at:

    https://github.com/${DOTFILES_REPO_SLUG}/blob/${DOTFILES_BRANCH}/install

Then re-run this script and explicitly skip installing system packages:

    bash <(curl -sS https://raw.githubusercontent.com/${DOTFILES_REPO_SLUG}/${DOTFILES_BRANCH}/install) --skip-system-packages
EOF

  exit 1
}

_package_install() {
  local manager="${1}"

  shift

  local packages=("${@}")

  ((${#packages[@]} == 0)) && return

  case "${manager}" in
  pacman)
    sudo pacman -Syu --noconfirm --needed "${packages[@]}"
    ;;
  yay)
    yay -S --noconfirm --needed "${packages[@]}"
    ;;
  apt)
    sudo apt-get update && sudo apt-get install -y --no-install-recommends "${packages[@]}"
    ;;
  brew)
    brew install "${packages[@]}"
    ;;
  brew-cask)
    brew install --cask "${packages[@]}"
    ;;
  mise)
    mise use --global "${packages[@]}"
    ;;
  esac
}

_install_packages_arch() {
  # Ensure GUI packages get skipped unless GUI is enabled.
  if [ "${GUI_ENABLED}" != "1" ]; then
    PACKAGES_PACMAN_GUI=()
    PACKAGES_PACMAN_GUI_EXTRAS=()
    PACKAGES_AUR_GUI=()
    PACKAGES_AUR_GUI_EXTRAS=()
  fi

  # Install Arch packages.
  _package_install pacman "${PACKAGES_PACMAN[@]}" "${PACKAGES_PACMAN_EXTRAS[@]}" "${PACKAGES_PACMAN_GUI[@]}" "${PACKAGES_PACMAN_GUI_EXTRAS[@]}"

  # Install Yay (AUR) if needed.
  local yay_local_version=
  yay_local_version="$(yay --version 2>/dev/null | cut -d " " -f 2)"

  local yay_latest_version=
  yay_latest_version="$(git ls-remote --tags https://github.com/Jguer/yay.git |
    grep -Eo "v?[0-9]+(\.[0-9]+){1,2}$" |
    sort --version-sort | tail -n 1)"

  if [ "${yay_local_version}" != "${yay_latest_version}" ]; then
    local yay_download_path="/tmp/yay-install"
    rm -rf "${yay_download_path}"
    git clone https://aur.archlinux.org/yay-bin.git "${yay_download_path}"
    cd "${yay_download_path}" && makepkg --syncdeps --install --noconfirm && cd -
    rm -rf "${yay_download_path}"
  fi

  # Install AUR packages.
  _package_install yay "${PACKAGES_AUR[@]}" "${PACKAGES_AUR_EXTRAS[@]}" "${PACKAGES_AUR_GUI[@]}" "${PACKAGES_AUR_GUI_EXTRAS[@]}"

  # Install Mise packages.
  _package_install mise "${MISE_ARCH[@]}" "${MISE_ARCH_EXTRAS[@]}"

  # Install packages manually since they don't exist elsewhere.

  # GIMP plugin: GEGL effects.
  if [ "${GUI_ENABLED}" == "1" ]; then
    local gegl_plugins_path="${XDG_DATA_HOME}/gegl-0.4/plug-ins"
    local gegl_zip_path="/tmp/gegl_effectd.zip"

    if [ ! -f "${gegl_plugins_path}/gegleffectspending.so" ]; then
      echo
      rm -rf "${gegl_zip_path}"
      curl -fsSL "https://github.com/LinuxBeaver/Gimp_Layer_Effects_Text_Styler_Plugin_GEGL_Effects/releases/download/Continual_July22_2023/gegl_effects_linux_binaries_gegl_plugin.zip" -o "${gegl_zip_path}"
      mkdir -p "${gegl_plugins_path}"
      unzip "${gegl_zip_path}" -d "${gegl_plugins_path}"
      rm -rf "${gegl_zip_path}"
    fi
  fi
}

_install_packages_debian() {
  # Install APT packages.
  _package_install apt "${PACKAGES_APT[@]}" "${PACKAGES_APT_EXTRAS[@]}"

  # Install Mise.
  sudo install -dm 755 /etc/apt/keyrings
  curl -fsSL https://mise.jdx.dev/gpg-key.pub | gpg --dearmor | sudo tee /etc/apt/keyrings/mise-archive-keyring.gpg 1>/dev/null
  echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.gpg arch=amd64] https://mise.jdx.dev/deb stable main" | sudo tee /etc/apt/sources.list.d/mise.list
  sudo apt-get update && sudo apt-get install -y mise

  # Install Mise packages.
  _package_install mise "${MISE_DEBIAN[@]}" "${MISE_DEBIAN_EXTRAS[@]}"

  # Install packages manually since they don't exist elsewhere.

  # fastfetch, Debian 13 / Ubuntu 26.04 LTS will have it in apt by default.
  echo
  curl -fsSL https://github.com/fastfetch-cli/fastfetch/releases/latest/download/fastfetch-linux-amd64.deb -o /tmp/fastfetch.deb
  sudo dpkg -i "${_}"
  rm "${_}"

  # git-delta, Debian 13 will have it in apt by default, Ubuntu 24.04+ LTS has it.
  echo
  curl -fsSL https://github.com/dandavison/delta/releases/download/0.18.2/git-delta_0.18.2_amd64.deb -o /tmp/git-delta.deb
  sudo dpkg -i "${_}"
  rm "${_}"
}

_install_packages_macos() {
  local prefix="/opt/homebrew"
  [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"

  # Ensure brew's paths are available for this script
  eval "$(${prefix}/bin/brew shellenv)"

  # Install Brew packages.
  _package_install brew "${PACKAGES_BREW[@]}" "${PACKAGES_BREW_EXTRAS[@]}"
  _package_install brew-cask "${PACKAGES_BREW_CASK[@]}" "${PACKAGES_BREW_CASK_EXTRAS[@]}"

  # Install Mise packages.
  _package_install mise "${MISE_MACOS[@]}" "${MISE_MACOS_EXTRAS[@]}"
}

_package_display() {
  local heading="${1}"

  shift

  local packages=("${@}")

  printf "\n:: %s\n" "${heading}"

  # Let's show something so it doesn't look like it was blindly skipped.
  if ((${#packages[@]} == 0)); then
    echo "   Skipping, since there's no packages defined"
    return
  fi

  for item in "${packages[@]}"; do
    echo "   - ${item}"
  done
}

_display_packages() {
  if [ "${OS_TYPE}" == "linux" ]; then
    if [ "${OS_DISTRO}" == "arch" ]; then
      _package_display "Pacman (default)" "${PACKAGES_PACMAN[@]}"
      _package_display "Pacman (extras)" "${PACKAGES_PACMAN_EXTRAS[@]}"
      [ "${GUI_ENABLED}" == "1" ] && _package_display "Pacman GUI (default)" "${PACKAGES_PACMAN_GUI[@]}"
      [ "${GUI_ENABLED}" == "1" ] && _package_display "Pacman GUI (extras)" "${PACKAGES_PACMAN_GUI_EXTRAS[@]}"
      _package_display "AUR (default)" "${PACKAGES_AUR[@]}"
      _package_display "AUR (extras)" "${PACKAGES_AUR_EXTRAS[@]}"
      [ "${GUI_ENABLED}" == "1" ] && _package_display "AUR GUI (default)" "${PACKAGES_AUR_GUI[@]}"
      [ "${GUI_ENABLED}" == "1" ] && _package_display "AUR GUI (extras)" "${PACKAGES_AUR_GUI_EXTRAS[@]}"
      _package_display "Mise (default)" "${MISE_ARCH[@]}"
      _package_display "Mise (extras)" "${MISE_ARCH_EXTRAS[@]}"

    elif [ "${OS_DISTRO}" == "debian" ]; then
      _package_display "APT (default)" "${PACKAGES_APT[@]}"
      _package_display "APT (extras)" "${PACKAGES_APT_EXTRAS[@]}"
      _package_display "Mise (default)" "${MISE_DEBIAN[@]}"
      _package_display "Mise (extras)" "${MISE_DEBIAN_EXTRAS[@]}"
    fi
  else
    _package_display "Brew (default)" "${PACKAGES_BREW[@]}"
    _package_display "Brew (extras)" "${PACKAGES_BREW_EXTRAS[@]}"
    _package_display "Brew Cask (default)" "${PACKAGES_BREW_CASK[@]}"
    _package_display "Brew Cask (extras)" "${PACKAGES_BREW_CASK_EXTRAS[@]}"
    _package_display "Mise (default)" "${MISE_MACOS[@]}"
    _package_display "Mise (extras)" "${MISE_MACOS_EXTRAS[@]}"
  fi
}

_config_install() {
  local str_find="${1:-}"
  local str_replace="${2:-}"
  local commands=("${@}")

  # This is a huge hack to detect if the first 2 args being passed in are
  # strings to do a template-like replacement. It can be refactored if the
  # use case ever changes.
  #
  # Basically this detects if %WindowsUser is passed in to chop out the first
  # 2 arguments for the string replacement so they are not commands.
  if [[ "${str_find}" == "%"* ]]; then
    shift 3
  else
    str_find=""
    str_replace=""
    shift
  fi

  ((${#commands[@]} == 0)) && return

  for item in "${commands[@]}"; do
    eval "${item//${str_find}/${str_replace}}"
  done
}

_config_install_display() {
  local heading="${1}"
  local str_find="${2:-}"
  local str_replace="${3:-}"

  if [[ "${str_find}" == "%"* ]]; then
    shift 3
  else
    str_find=""
    str_replace=""
    shift
  fi

  local commands=("${@}")

  printf "\n:: %s\n" "${heading}"

  # Let's show something so it doesn't look like it was blindly skipped.
  if ((${#commands[@]} == 0)); then
    echo "   Skipping, since there's no config commands defined"
    return
  fi

  for item in "${commands[@]}"; do
    echo "   - ${item//${str_find}/${str_replace}}"
  done
}

# -----------------------------------------------------------------------------
# Main functions
# -----------------------------------------------------------------------------

bootstrap() {
  _info "BOOTSTRAP NEW INSTALLATION"

  rm -rf "${BOOTSTRAP_PATH}"
  mkdir -p "${BOOTSTRAP_PATH}"

  if [ "${LOCAL}" == "1" ]; then
    [ "${IN_CONTAINER}" == "1" ] && DOTFILES_PATH="/app"

    if [ -n "${DOTFILES_PATH}" ]; then
      cp "${DOTFILES_PATH}/install" "${BOOTSTRAP_PATH}/install"
      cp "${DOTFILES_PATH}/install-config.example" "${BOOTSTRAP_PATH}/install-config.example"
    else
      echo "LOCAL=1 cannot be used if DOTFILES_PATH is unset, aborting!" >&2
      exit 1
    fi
  else
    curl -sSL "https://raw.githubusercontent.com/${DOTFILES_REPO_SLUG}/${DOTFILES_BRANCH}/install" \
      -o "${BOOTSTRAP_PATH}/install"
    curl -sSL "https://raw.githubusercontent.com/${DOTFILES_REPO_SLUG}/${DOTFILES_BRANCH}/install-config.example" \
      -o "${BOOTSTRAP_PATH}/install-config.example"
  fi

  mv "${BOOTSTRAP_PATH}/install-config.example" "${BOOTSTRAP_PATH}/install-config"
  chmod +x "${BOOTSTRAP_PATH}/install"

  # This only exists now, so let's source it.
  # shellcheck disable=SC1091
  . ./install-config

  cat <<EOF
:: Welcome to ${DOTFILES_REPO_SLUG}!

Given this is your first run, a few temporary files were downloaded to
'/tmp/nickjj-dotfiles' which is where you'll kick off running the install
script. It is set up this way so you have a chance to review a few config
values before running anything on your system.

We'll be deleting the above at the end so don't worry about the path.

:: Optionally view the install script's config file

cat ${BOOTSTRAP_PATH}/install-config

If you're ok with everything (packages, symlinks, etc.) then you're good to go
to install these dotfiles. Feel free to edit the install-config file beforehand
if you want to make adjustments. The installed dotfiles will have the same
config file copied over which you can edit at any time.

:: Install these dotfiles

${BOOTSTRAP_PATH}/install

The above will re-run this script but instead of setting up temp files it will
walk you through picking where to install these dotfiles and install /
configure everything. From this point on you'll always be running the install
script from your dotfiles repo.

:: Delete the temporary directory

rm -rf ${BOOTSTRAP_PATH}

Once you've installed these dotfiles you can delete this temp directory.
EOF
}

detect_env() {
  case "${OS_TYPE}" in
  linux)
    if [ -r /etc/os-release ]; then
      # shellcheck disable=SC1091
      OS_DISTRO="$(. /etc/os-release && echo "${ID_LIKE:-${ID}}")"

      # Technically ID_LIKE can have a space separated list of distros but
      # we really only care that we have a Debian based system where apt is
      # available to use.
      [[ "${OS_DISTRO}" =~ (ubuntu|debian) ]] && OS_DISTRO="debian"
    fi

    # Only fully support these Linux distros.
    if [[ -z "${OS_DISTRO}" || ! "arch ubuntu debian raspbian" =~ ${OS_DISTRO} ]]; then
      [ "${SKIP_SYSTEM_PACKAGES}" != "1" ] && _no_system_packages
    fi

    # Are we in WSL?
    if grep -q "\-WSL2" /proc/version; then
      OS_IN_WSL=1
    fi

    # Can we install and configure a window manager and GUI tools?
    if [[ "${GUI_LINUX}" == "1" && "${OS_DISTRO}" = "arch" && "${OS_IN_WSL}" != "1" && "${IN_CONTAINER}" != "1" ]]; then
      GUI_ENABLED=1
    fi
    ;;
  darwin) ;;
  *)
    _error "'${OS_TYPE}' is not supported"

    ;;
  esac
}

detect_and_prepare_gpu() {
  _info "DETECT AND PREPARE GPU"

  if [[ "${GUI_ENABLED}" != "1" || "${SKIP_SYSTEM_PACKAGES}" == "1" ]]; then
    echo "Skipping, since this only runs when GUI_LINUX=1 is set with packages"
    return
  fi

  local kernel=
  kernel="$(uname -r)"

  local kernel_package=
  case "${kernel}" in
  *arch*)
    kernel_package="linux-headers"
    ;;
  *lts*)
    kernel_package="linux-lts-headers"
    ;;
  *zen*)
    kernel_package="linux-zen-headers"
    ;;
  *hardened*)
    kernel_package="linux-hardened-headers"
    ;;
  *)
    cat <<EOF

'${kernel}' Linux kernel was detected but this script doesn't automatically
support it because it can't determine which linux-*-headers package to install.

If you think it should work, please open an issue with the above output.

EOF
    _error "Unknown Linux Kernel found, aborting!"
    ;;
  esac

  local lspci_output=
  lspci_output="$(lspci)"

  local gpu_line=
  gpu_line="$(grep --ignore-case -E "VGA|3D controller" <<<"${lspci_output}" | head -n 1 || true)"

  [ -z "${gpu_line}" ] && _error "No GPU detected, aborting!"

  echo "${gpu_line}"

  case "${gpu_line}" in
  *NVIDIA*)
    PACKAGES_PACMAN+=("${kernel_package}")

    # Avoid recreating the file every time, if a user changes it manually then
    # let's not clobber their changes.
    if [ ! -f /etc/modprobe.d/nvidia.conf ]; then
      echo "options nvidia-drm modeset=1" | sudo tee /etc/modprobe.d/nvidia.conf >/dev/null
    fi

    # Choose driver based on generation.
    case "${gpu_line}" in
    *RTX\ [2-9][0-9]* | *GTX\ 16*)
      PACKAGES_PACMAN+=("nvidia-open-dkms" "nvidia-utils")
      ;;
    *GTX\ [7-9]* | *GTX\ 10*)
      PACKAGES_AUR+=("nvidia-580xx-dkms" "nvidia-580xx-utils")
      ;;
    *)
      cat <<EOF

See if your GPU is listed here: https://wiki.archlinux.org/title/NVIDIA

If you think it should work, please open an issue with the above device output.

EOF
      _error "Unsupported NVIDIA GPU found, aborting!"
      ;;
    esac
    ;;
  *AMD*)
    # AMD drivers are handled automatically by the Linux kernel.
    ;;
  *Intel*)
    # Choose driver based on generation.
    case "${gpu_line}" in
    *HD\ Graphics* | *Iris* | *Xe*)
      PACKAGES_PACMAN+=("intel-media-driver")
      ;;
    *GMA*)
      PACKAGES_PACMAN+=("libva-intel-driver")
      ;;
    *)
      cat <<EOF

See if your GPU is listed here: https://wiki.archlinux.org/title/Intel_graphics

If you think it should work, please open an issue with the above device output.

EOF

      _error "Unsupported Intel GPU found, aborting!"
      ;;
    esac
    ;;
  *)
    cat <<EOF
$(grep --ignore-case "VGA" <<<"${lspci_output}")

Most variants of NVIDIA, AMD and Intel GPUs should all be supported.

If you think it should work, please open an issue with the above device output.

EOF

    _error "Unsupported GPU found, aborting!"
    ;;
  esac
}

detect_and_prepare_network() {
  _info "DETECT AND PREPARE NETWORK"

  if [[ "${GUI_ENABLED}" != "1" || "${SKIP_SYSTEM_PACKAGES}" == "1" ]]; then
    echo "Skipping, since this only runs when GUI_LINUX=1 is set with packages"
    return
  fi

  if compgen -G "/sys/class/net/*/wireless" 1>/dev/null; then
    PACKAGES_PACMAN+=("impala" "iwd")
    SYSTEMD_ENABLED_SERVICES+=("iwd")

    echo "Wi-Fi adapter found, iwd + impala packages will be installed"
  else
    echo "Ethernet adapter found, no preparation is necessary"
  fi
}

detect_and_prepare_bluetooth() {
  _info "DETECT AND PREPARE BLUETOOTH"

  if [[ "${GUI_ENABLED}" != "1" || "${SKIP_SYSTEM_PACKAGES}" == "1" ]]; then
    echo "Skipping, since this only runs when GUI_LINUX=1 is set with packages"
    return
  fi

  if [ -d "/sys/class/bluetooth" ]; then
    PACKAGES_PACMAN+=("bluetui" "bluez")
    SYSTEMD_ENABLED_SERVICES+=("bluetooth")

    echo "Compatible adapter found, bluez + bluetui packages will be installed"
  else
    echo "Skipping, since no Bluetooth adapter was found"
  fi
}

warn_root() {
  # Root will have an effective uid of 0, but it's ok if we're in a container.
  [[ "${EUID}" != 0 || "${IN_CONTAINER}" == "1" ]] && return 0

  cat <<EOF
Here are details about this user:

$(id)

EOF

  local msg="as root"
  [[ -n "${SUDO_USER}" ]] && msg="with sudo as ${SUDO_USER}"

  while true; do
    read -rp "This script is meant to run as a non-root user, are you sure you want to run this ${msg}? (y/n) " yn
    case "${yn}" in
    [Yy]*) break ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

check_prereqs() {
  _info "CHECKING SYSTEM COMPATABILITY"

  local missing_packages=()

  if ! command -v "sudo" 1>/dev/null; then missing_packages+=("sudo"); fi

  if [[ -z "${missing_packages[*]}" ]]; then
    # Request a user's password early so it's not buried mid-script.
    sudo -v

    echo "Everything is good to go"
    return 0
  fi

  cat <<EOF
This script is going to switch to the root user to install sudo then the rest
of the script will run as your user and use sudo as needed.

EOF

  case "${OS_DISTRO}" in
  arch)
    su -c "pacman -Syu --noconfirm --needed ${missing_packages[*]}"
    ;;
  debian)
    su -c "apt-get update && apt-get install -y ${missing_packages[*]}"
    ;;
  *) ;;
  esac
}

create_initial_dirs() {
  mkdir -p \
    "${HOME}/.local/bin" \
    "${XDG_CACHE_HOME}/zsh" \
    "${XDG_CONFIG_HOME}/bat" \
    "${XDG_CONFIG_HOME}/btop/themes" \
    "${XDG_CONFIG_HOME}/fzf" \
    "${XDG_CONFIG_HOME}/ghostty" \
    "${XDG_CONFIG_HOME}/git" \
    "${XDG_CONFIG_HOME}/gitui" \
    "${XDG_CONFIG_HOME}/tmux/plugins" \
    "${XDG_CONFIG_HOME}/zsh" \
    "${XDG_DATA_HOME}/fonts" \
    "${XDG_STATE_HOME}"

  if [ "${GUI_ENABLED}" == "1" ]; then
    mkdir -p \
      "${XDG_CACHE_HOME}/mpd" \
      "${XDG_CONFIG_HOME}/fontconfig" \
      "${XDG_CONFIG_HOME}/hypr" \
      "${XDG_CONFIG_HOME}/mako" \
      "${XDG_CONFIG_HOME}/mpd" \
      "${XDG_CONFIG_HOME}/niri" \
      "${XDG_CONFIG_HOME}/rmpc" \
      "${XDG_CONFIG_HOME}/satty" \
      "${XDG_CONFIG_HOME}/swayidle" \
      "${XDG_CONFIG_HOME}/swaylock" \
      "${XDG_CONFIG_HOME}/tumbler" \
      "${XDG_CONFIG_HOME}/uwsm" \
      "${XDG_CONFIG_HOME}/walker/themes/base" \
      "${XDG_CONFIG_HOME}/wallpaper" \
      "${XDG_CONFIG_HOME}/waybar" \
      "${XDG_DATA_HOME}/applications" \
      "${XDG_DESKTOP_DIR}" \
      "${XDG_DOCUMENTS_DIR}" \
      "${XDG_DOWNLOAD_DIR}" \
      "${XDG_MUSIC_DIR}/playlists" \
      "${XDG_PICTURES_DIR}" \
      "${XDG_PUBLICSHARE_DIR}" \
      "${XDG_TEMPLATES_DIR}" \
      "${XDG_VIDEOS_DIR}"
  fi
}

install_packages() {
  _info "INSTALL PACKAGES"

  if [ -n "${SKIP_SYSTEM_PACKAGES}" ]; then
    echo "Skipping, you've chosen not to or your distro isn't fully supported"
    return
  fi

  cat <<EOF
If you choose y, all of the packages below will be installed:
$(_display_packages)

If you choose no, the above packages will not be installed and this script
will exit. This gives you a chance to edit the list of packages.

You can edit 'install-config' to modify the package list(s).

EOF

  while true; do
    read -rp "Do you want to install the above packages? (y/n) " yn
    case "${yn}" in
    [Yy]*)
      if [ "${OS_TYPE}" == "linux" ]; then
        if [ "${OS_DISTRO}" == "arch" ]; then
          _install_packages_arch
        elif [ "${OS_DISTRO}" == "debian" ]; then
          _install_packages_debian
        fi
      else
        _install_packages_macos
      fi

      break
      ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

check_install_config() {
  _info "CHECK INSTALL CONFIG FOR UPDATES"

  example_file="install-config.example"
  real_file="install-config"

  if [ "${example_file}" -nt "${real_file}" ]; then
    delta --paging=never install-config install-config.example || true

    cat <<EOF

---

The above is a diff between your ${real_file} and the ${example_file}.
Anything you see in green is in the updated ${example_file}.

It's completely normal for you to see your custom changes here but the
${example_file} file has a newer mtime (modified time) than your config
which indicates it might have new updates for you to merge into your ${real_file}.

This merge cannot be automated in a reasonable way so you'll want to eyeball it
and copy over new lines, remove unused lines or update existing defaults.

If you want to proceed anyways you can run: touch ${real_file}

The above will update your config's mtime, but be warned this could allow the
install script to run in unintended ways with missing configuration values.

EOF

    _error "There are potentially new updates to merge into your '${real_file}'"

  else
    echo "Skipping, since '${real_file}' is up to date"
  fi
}

update_dotfiles() {
  _info "UPDATE DOTFILES"

  if [ -z "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since this is the first time you've run this script"
    return 0
  fi

  if [[ "${PULL}" != "1" && "${PULL_UPDATE}" != "1" ]]; then
    echo "Skipping, rerun with --pull or --update to get the latest changes"
    return 0
  fi

  if [ "${LOCAL}" == "1" ]; then
    echo "Skipping, since LOCAL=1 is set we'll avoid remote updates"
    return 0
  fi

  # This feels like a good default because it lets you check a branch out
  # locally and potentially merge into that without needing to change anything.
  local local_branch=
  local_branch="$(git -C "${DOTFILES_PATH}" branch --show-current)"

  # This is explained a bit further down.
  local test_branch="${2:-}"

  if [[ -z "${local_branch}" && -z "${test_branch}" ]]; then
    _error "Are you in a detached state? Checkout a branch before --pull | --update, aborting!"
  fi

  # If a custom branch name was set, we're testing a branch which means
  # we want both the remote + local branches to be the same to avoid merging
  # into the currently checked out branch (likely master).
  if [ -n "${test_branch}" ]; then
    if ! git ls-remote --exit-code --heads origin "${test_branch}" 1>/dev/null; then
      _error "Remote branch '${test_branch}' does not exist, aborting!"
    fi

    local_branch="${test_branch}"
    DOTFILES_BRANCH="${test_branch}"

    git -C "${DOTFILES_PATH}" fetch --quiet origin "${DOTFILES_BRANCH}"

    # Create the branch locally if it doesn't exist. Quiet is skipped here
    # because showing that a new branch was created seems useful.
    if ! git show-ref --quiet --verify "refs/heads/${local_branch}"; then
      git -C "${DOTFILES_PATH}" checkout -b "${local_branch}" "origin/${DOTFILES_BRANCH}"
    fi
  else
    # If there's no custom branch passed in, we only need to fetch.
    git -C "${DOTFILES_PATH}" fetch --quiet origin "${DOTFILES_BRANCH}"
  fi

  local new_commit_count=
  new_commit_count="$(git -C "${DOTFILES_PATH}" rev-list "${local_branch}..origin/${DOTFILES_BRANCH}" --count)"

  if [ "${new_commit_count}" = "0" ]; then
    echo "Skipping, since local '${local_branch}' has the latest commits from remote '${DOTFILES_BRANCH}'"
  else
    # Let's merge the latest updates into the local branch.
    git -C "${DOTFILES_PATH}" checkout --quiet "${local_branch}"
    git -C "${DOTFILES_PATH}" merge "origin/${DOTFILES_BRANCH}"

    # Insurance to always make sure an install-config exists.
    cp -n "${DOTFILES_PATH}/install-config.example" "${DOTFILES_PATH}/install-config"

    # Re-run this script because if an update happened, it's possible new
    # configuration was introduced which means reading in their env vars.
    exec "${0}" "${@}"
  fi
}

clone_dotfiles() {
  _info "CLONE DOTFILES"

  if [ -d "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since DOTFILES_PATH already exists at '${DOTFILES_PATH}'"
    return 0
  fi

  local default_dotfiles_path="${HOME}/dotfiles"

  read -rep "Where do you want to clone these dotfiles to [${default_dotfiles_path}]? " dotfiles_path
  echo

  [[ -z "${dotfiles_path}" ]] && dotfiles_path="${default_dotfiles_path}"

  DOTFILES_PATH="${dotfiles_path//\~/"${HOME}"}"

  _local_clone && return 0

  git clone --branch "${DOTFILES_BRANCH}" "${DOTFILES_CLONE_URL}" "${DOTFILES_PATH}"
  git -C "${DOTFILES_PATH}" remote | grep -qw upstream ||
    git -C "${DOTFILES_PATH}" remote add upstream "${DOTFILES_UPSTREAM_URL}.git"

  # Carry over the bootstrapped config if it exists, but have a fallback plan.
  cp "${BOOTSTRAP_PATH}/install-config" "${DOTFILES_PATH}/install-config" 2>/dev/null || true
  cp -n "${DOTFILES_PATH}/install-config.example" "${DOTFILES_PATH}/install-config"
}

install_fonts() {
  _info "INSTALL FONTS"

  local font_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/Inconsolata.zip"
  local font_tmp="/tmp/inconsolata"
  local font_zip="/tmp/inconsolata.zip"
  local font_filename="InconsolataNerdFontMono-Regular.ttf"
  local windows_font_path="/mnt/c/Windows/Fonts"
  local macos_font_path="${HOME}/Library/Fonts"
  local linux_font_path="${XDG_DATA_HOME}/fonts"
  local font_path=
  local font_is_installed=

  if [ "${OS_TYPE}" = "linux" ]; then
    font_path="${linux_font_path}"

    if [ "${OS_IN_WSL}" == "1" ]; then
      font_path="${windows_font_path}"
    fi
  else
    font_path="${macos_font_path}"
  fi

  [ -f "${font_path}/${font_filename}" ] && font_is_installed=1

  if [ -n "${font_is_installed}" ]; then
    echo "Skipping, since fonts are already installed at '${font_path}'"
  else
    rm -rf "${font_zip}" "${font_tmp}"
    curl -sSL "${font_url}" -o "${font_zip}"
    unzip "${font_zip}" -d "${font_tmp}"

    if [ "${OS_IN_WSL}" == "1" ]; then
      cat <<EOF

Since we're in WSL 2 and we need to install Windows fonts, please do it manually.

Most of it has been automated for you, from within WSL 2 perform these steps:

1. cd ${font_tmp}
2. explorer.exe .
3. Right click the fonts and INSTALL FOR ALL USERS
4. rm -rf "${font_zip}" "${font_tmp}"

It's important step 3 is for all users not your personal user. It's also
important step 4 is executed so this script doesn't always download the font's
zip file and extract it to step 1.
EOF

      return 0
    fi

    cp "${font_tmp}"/InconsolataNerdFont*.ttf "${font_path}"

    # Update font cache on native Linux.
    [[ "${OS_TYPE}" = "linux" ]] && fc-cache -fv

    rm -rf "${font_zip}" "${font_tmp}"
  fi
}

install_zsh_plugins() {
  _info "INSTALL ZSH PLUGINS"

  "${DOTFILES_PATH}/.local/bin/dot-update-zsh-plugins"
}

create_configs() {
  _info "CREATE CONFIGS"

  local config_install=()
  local config_install_gui_linux=()
  local config_install_wsl=()
  local config_install_arch=()

  ((${#CONFIG_INSTALL[@]} > 0)) && config_install+=("${CONFIG_INSTALL[@]}")
  ((${#CONFIG_INSTALL_EXTRAS[@]} > 0)) && config_install+=("${CONFIG_INSTALL_EXTRAS[@]}")

  ((${#CONFIG_INSTALL_GUI_LINUX[@]} > 0)) && config_install_gui_linux+=("${CONFIG_INSTALL_GUI_LINUX[@]}")
  ((${#CONFIG_INSTALL_GUI_LINUX_EXTRAS[@]} > 0)) && config_install_gui_linux+=("${CONFIG_INSTALL_GUI_LINUX_EXTRAS[@]}")

  ((${#CONFIG_INSTALL_WSL[@]} > 0)) && config_install_wsl+=("${CONFIG_INSTALL_WSL[@]}")
  ((${#CONFIG_INSTALL_WSL_EXTRAS[@]} > 0)) && config_install_wsl+=("${CONFIG_INSTALL_WSL_EXTRAS[@]}")

  ((${#CONFIG_INSTALL_ARCH[@]} > 0)) && config_install_arch+=("${CONFIG_INSTALL_ARCH[@]}")
  ((${#CONFIG_INSTALL_ARCH_EXTRAS[@]} > 0)) && config_install_arch+=("${CONFIG_INSTALL_ARCH_EXTRAS[@]}")

  _config_install_display "Configs" "${config_install[@]}"

  if [ "${GUI_ENABLED}" == "1" ]; then
    _config_install_display "Configs (GUI)" "${config_install_gui_linux[@]}"
  fi

  if [ "${OS_IN_WSL}" == "1" ]; then
    local windows_user=

    # shellcheck disable=SC2016
    windows_user="$(powershell.exe '$env:UserName' 2>/dev/null | tr -d '\r\n')"

    _config_install_display "Configs (WSL)" "%WindowsUser" "${windows_user}" "${config_install_wsl[@]}"
  fi

  if [ "${OS_DISTRO}" == "arch" ]; then
    # It's a bit more complicated to extract this into a variable since it has
    # a condition with a fallback. For now let's keep it hard coded until a
    # better pattern arrises to handle this in a dynamic way.
    if [ -f "etc/pacman.d/02-ignore.conf" ]; then
      config_install_arch+=("sudo ln -fns \"${DOTFILES_PATH}/etc/pacman.d/02-ignore.conf\" \"/etc/pacman.d/02-ignore.conf\"")
    else
      sudo rm -f "/etc/pacman.d/02-ignore.conf"
    fi

    _config_install_display "Configs (Arch)" "${config_install_arch[@]}"
  fi

  cat <<EOF

-------------------------------------------------------------------------------

A potentially destructive action is about to happen. The above directories and
files are going to get forcefully overwritten if you type y in the prompt below.

What does that mean?

Any config files you have on the right hand side of the paths are going to get
overwritten with the files that come with these dotfiles (left side).

Without this action, these dotfiles will not work as is. If you plan to
type y and have existing files now would be a good time to back them up.

EOF

  while true; do
    read -rep "Ready to continue? Enter y to apply them all or n to skip (y/n) " yn
    case "${yn}" in
    [Yy]*)
      # Avoid using ln -T flag since it doesn't exist on macOS. We're being
      # extra careful here to only delete symlinks if they exist. Technically
      # rm -f would work but that could delete real files potentially.
      [ -L "${XDG_CONFIG_HOME}/nvim" ] && rm "${XDG_CONFIG_HOME}/nvim"

      _config_install "${config_install[@]}"

      [ "${GUI_ENABLED}" == "1" ] && _config_install "${config_install_gui_linux[@]}"
      [ "${OS_IN_WSL}" == "1" ] && _config_install "%WindowsUser" "${windows_user}" "${config_install_wsl[@]}"
      [ "${OS_DISTRO}" == "arch" ] && _config_install "${config_install_arch[@]}"

      break
      ;;
    [Nn]*)

      break
      ;;
    *) echo "Please answer y or n" ;;
    esac
  done
}

configure_sudoers_entries() {
  _info "CONFIGURE SUODERS ENTRIES"

  if [ -z "${USER}" ]; then
    echo "Skipping, since \$USER is not set"
    return
  fi

  declare -A sudoers_entries

  # Merge both arrays.
  for key in "${!SUDOERS_ENTRIES[@]}"; do
    sudoers_entries["${key}"]="${SUDOERS_ENTRIES[${key}]}"
  done
  for key in "${!SUDOERS_ENTRIES_EXTRAS[@]}"; do
    sudoers_entries["${key}"]="${SUDOERS_ENTRIES_EXTRAS[${key}]}"
  done

  if ((${#sudoers_entries[@]} == 0)); then
    echo "Skipping, since there's no entries set"
    return
  fi

  for key in "${!sudoers_entries[@]}"; do
    [[ "${key}" = "0" || -z "${sudoers_entries[${key}]}" ]] && continue
    echo "${sudoers_entries[${key}]}" | sudo tee "/etc/sudoers.d/${key}"
  done

  sudo chmod -R 440 /etc/sudoers.d
  echo

  echo "They have been configured in '/etc/sudoers.d/'"
}

configure_systemd_services() {
  _info "CONFIGURE SYSTEMD SERVICES"

  if [ "${GUI_ENABLED}" != "1" ]; then
    echo "Skipping, since this only runs on Linux when GUI_LINUX=1 is set"
    return
  fi

  local services=(
    "${SYSTEMD_ENABLED_SERVICES[@]}"
    "${SYSTEMD_ENABLED_SERVICES_EXTRAS[@]}"
  )

  if ((${#services[@]} == 0)); then
    echo "Skipping, since there's no services defined"
    return
  fi

  for service in "${services[@]}"; do
    if systemctl cat "${service}.service" 1>/dev/null; then
      sudo systemctl enable "${service}.service"
      echo "${service}"
    fi

    echo
  done

  echo "They have been configured to start on boot"
}

configure_system_configs() {
  _info "CONFIGURE SYSTEM CONFIGS"

  if [ "${OS_DISTRO}" = "arch" ]; then
    local etc_pacman_conf_path="/etc/pacman.conf"
    if ! grep -q "Include = /etc/pacman\.d/\*\.conf" "${etc_pacman_conf_path}" 2>/dev/null; then
      printf "\nInclude = /etc/pacman.d/*.conf\n" | sudo tee --append "${etc_pacman_conf_path}" 1>/dev/null
    fi
  fi

  # If Docker is being installed, ensure the user is in the docker group.
  if [[ "${PACMAN_PACKAGES_GUI}" == *docker* && "${GUI_ENABLED}" == "1" ]]; then
    if ! groups "${USER}" | grep --quiet "\bdocker\b"; then
      sudo usermod -aG docker "${USER}"
    fi
  fi

  echo "Everything that required configuring was updated"
}

configure_home_configs() {
  _info "CONFIGURE HOME CONFIGS"

  local ghostty_config="${XDG_CONFIG_HOME}/ghostty/config.local"

  if [ ! -f "${ghostty_config}" ]; then
    printf "# Add your custom overrides and new additions here.\n" >"${ghostty_config}"
  fi

  if [ "${GUI_ENABLED}" == "1" ]; then
    local mako_config="${XDG_CONFIG_HOME}/mako/config.local"
    if [ ! -f "${mako_config}" ]; then
      printf "# Add your custom overrides and new additions here.\n" >"${mako_config}"
    fi

    local wm_config="${XDG_CONFIG_HOME}/niri/config.kdl.local"
    if [ ! -f "${wm_config}" ]; then
      cat <<EOF >"${wm_config}"
// Add your custom overrides and new additions here.

// ----------------------------------------------------------------------------
// Outputs (monitors, etc.)
// Find details about them by running: niri msg outputs
// ----------------------------------------------------------------------------

// Set external display as the left monitor and have it get used by default.
// output "DP-2" {
//     position x=0 y=0
//     focus-at-startup
// }

// output "eDP-1" {
//     position x=2560 y=0
// }
EOF
    fi
  fi

  echo "Everything that required configuring was updated"
}

configure_home_binaries() {
  _info "CONFIGURE HOME BINARIES"

  # The bat tool has a different binary name on Debian based systems.
  if [[ "${OS_TYPE}" == "linux" && "${OS_DISTRO}" == "debian" ]]; then
    ln -fns /usr/bin/batcat "${HOME}/.local/bin/bat"
  fi

  echo "Everything that required configuring was updated"
}

configure_xdg_directories() {
  _info "CONFIGURE XDG DIRECTORIES"

  local xdg_local_path="${DOTFILES_PATH}/.config/zsh/.xdg.local"

  cat <<EOF >"${xdg_local_path}"
# shellcheck shell=bash

# These are set from the dotfiles' install-config script, update the values
# in that file not here since they will get overwritten.

# XDG base directories.
export XDG_CACHE_HOME="${XDG_CACHE_HOME}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME}"
export XDG_DATA_HOME="${XDG_DATA_HOME}"
export XDG_STATE_HOME="${XDG_STATE_HOME}"
EOF

  if [ "${GUI_ENABLED}" == "1" ]; then
    cat <<EOF >>"${xdg_local_path}"

# XDG user directories.
export XDG_DESKTOP_DIR="${XDG_DESKTOP_DIR}"
export XDG_DOCUMENTS_DIR="${XDG_DOCUMENTS_DIR}"
export XDG_DOWNLOAD_DIR="${XDG_DOWNLOAD_DIR}"
export XDG_MUSIC_DIR="${XDG_MUSIC_DIR}"
export XDG_PICTURES_DIR="${XDG_PICTURES_DIR}"
export XDG_PUBLICSHARE_DIR="${XDG_PUBLICSHARE_DIR}"
export XDG_TEMPLATES_DIR="${XDG_TEMPLATES_DIR}"
export XDG_VIDEOS_DIR="${XDG_VIDEOS_DIR}"
EOF

    cat <<EOF >"${XDG_CONFIG_HOME}/user-dirs.dirs"
# These are set from the dotfiles' install-config script, update the values
# in that file not here since they will get overwritten.

export XDG_DESKTOP_DIR="${XDG_DESKTOP_DIR}"
export XDG_DOCUMENTS_DIR="${XDG_DOCUMENTS_DIR}"
export XDG_DOWNLOAD_DIR="${XDG_DOWNLOAD_DIR}"
export XDG_MUSIC_DIR="${XDG_MUSIC_DIR}"
export XDG_PICTURES_DIR="${XDG_PICTURES_DIR}"
export XDG_PUBLICSHARE_DIR="${XDG_PUBLICSHARE_DIR}"
export XDG_TEMPLATES_DIR="${XDG_TEMPLATES_DIR}"
export XDG_VIDEOS_DIR="${XDG_VIDEOS_DIR}"
EOF

    cat <<EOF >"${XDG_CONFIG_HOME}/user-dirs.conf"
# Prevent custom XDG paths in user-dirs.dir from being overwritten on boot.
enabled=False
EOF
  fi

  echo "They have been configured in '${xdg_local_path}'"
}

configure_shell() {
  _info "CONFIGURE SHELL (ZSH)"

  local local_files=(".zshrc.local" ".zprofile.local" ".aliases.local")
  local original_dotfiles_path="${DOTFILES_PATH}"

  for file in "${local_files[@]}"; do
    local file_path="${XDG_CONFIG_HOME}/zsh/${file}"

    if [ ! -f "${file_path}" ]; then
      printf "# shellcheck shell=bash\n# Add your custom overrides and new additions here.\n" >"${file_path}"
    fi
  done

  local zprofile_path="${DOTFILES_PATH}/.config/zsh/.zprofile.local"
  local aliases_path="${DOTFILES_PATH}/.config/zsh/.aliases.local"

  if ! grep -q "^export DOTFILES_PATH=.*$" "${zprofile_path}" 2>/dev/null; then
    printf '\nexport DOTFILES_PATH="%s"\n' "${DOTFILES_PATH}" >>"${zprofile_path}"
  fi

  if [ "${OS_TYPE}" == "darwin" ]; then
    if ! grep -q "HOMEBREW_NO_ANALYTICS" "${zprofile_path}" 2>/dev/null; then
      printf '\nexport HOMEBREW_NO_ANALYTICS=1\n' >>"${zprofile_path}"
    fi

    if ! grep -q "eval.*homebrew.*shellenv" "${zprofile_path}" 2>/dev/null; then
      local prefix="/opt/homebrew"
      [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"

      # shellcheck disable=SC2016
      printf "\neval \"\$(%s/bin/brew shellenv)\"\n" "${prefix}" >>"${zprofile_path}"
    fi

    if ! grep -q '^alias ls="ls -G"' "${aliases_path}" 2>/dev/null; then
      cat <<EOF >>"${aliases_path}"

alias ls="ls -G"
alias grep="grep -G"
alias fgrep="fgrep -G"
alias egrep="egrep -G"
EOF
    fi
  else
    if ! grep -q 'alias ls="ls --color=auto"' "${aliases_path}" 2>/dev/null; then
      cat <<EOF >>"${aliases_path}"

alias ls="ls --color=auto"
alias grep="grep --color=auto"
alias fgrep="fgrep --color=auto"
alias egrep="egrep --color=auto"
EOF
    fi

    # Is a Linux GUI supported?
    if [ "${GUI_ENABLED}" == "1" ]; then
      if ! grep -q "^if uwsm check may-start.*$" "${zprofile_path}" 2>/dev/null; then
        printf "\n# Start niri after logging in.\nif uwsm check may-start; then exec uwsm start -F -- niri-session -l; fi\n" >>"${zprofile_path}"
      fi
    # Are we in WSL 2?
    elif [ "${OS_IN_WSL}" == "1" ]; then
      # This only applies if you have Docker installed without Docker Desktop
      # and you're not using systemd.
      if command -v docker >/dev/null 2>&1; then
        if [ ! -d "${HOME}/.docker/desktop" ]; then
          if [ ! -d /run/systemd/system ]; then
            if ! grep -q "^if service docker status.*$" "${zprofile_path}" 2>/dev/null; then
              local docker=
              docker=$(
                cat <<'EOF'
# Ensure Docker is running on WSL 2. This expects you've installed Docker and
# Docker Compose directly within your WSL distro instead of Docker Desktop, such as:
#   - https://nickjanetakis.com/blog/install-docker-in-wsl-2-without-docker-desktop
if service docker status 2>&1 | grep -q "is not running"; then
wsl.exe --distribution "${WSL_DISTRO_NAME}" --user root \
  --exec /usr/sbin/service docker start >/dev/null 2>&1
fi
EOF
              )

              printf "\n\n%s" "${docker}" >>"${zprofile_path}"
            fi
          fi
        fi
      fi

      if ! grep -q '^alias drop_cache=' "${aliases_path}" 2>/dev/null; then
        cat <<EOF >>"${aliases_path}"

# This is specific to WSL 2. If the WSL 2 VM goes rogue and decides not to free
# up memory, this command will free your memory after about 20-30 seconds.
#   Details: https://github.com/microsoft/WSL/issues/4166#issuecomment-628493643
alias drop_cache="sudo sh -c \"echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\n%s\n' 'Ram-cache and Swap Cleared'\""
EOF
      fi

      if ! grep -q '^alias open="/mnt/c/Program' "${aliases_path}" 2>/dev/null; then
        cat <<EOF >>"${aliases_path}"

alias open="/mnt/c/Program\ Files/Mozilla\ Firefox/firefox.exe"
alias wopen="cmd.exe /C start 2> /dev/null"
EOF
      fi
    fi
  fi

  # Switch to zsh in a way that supports our supported OS and distros.
  local shell_path=
  shell_path="$(which zsh)"

  if ! grep -q "${shell_path}" /etc/shells; then
    echo "${shell_path}" | sudo tee -a /etc/shells 1>/dev/null
  fi

  [ "${SHELL: -3}" != "zsh" ] && chsh -s "${shell_path}"

  # shellcheck disable=SC1091
  . "${XDG_CONFIG_HOME}/zsh/.zprofile"

  # Given the above line sets this env var if it's defined, this ensures we
  # always use the value that was set when running this script. This is mainly
  # to make testing this script easier in Docker since the .local files are
  # volume mounted and this value will be different in Docker.
  DOTFILES_PATH="${original_dotfiles_path}"

  echo "It has been configured in '${DOTFILES_PATH}/zsh/'"
}

ask_for_name() {
  _info "ASKING FOR YOUR NAME TO CONFIGURE GIT"

  local name=

  set +o errexit
  name="$(git config user.name)"
  set -o errexit

  if [[ -n "${name}" ]]; then
    echo "Skipping, since '${name}' was retrieved from your git config"
  else
    [ -n "${YOUR_NAME}" ] &&
      echo "Skipping, since '${YOUR_NAME}' was retrieved from your install config" &&
      return 0

    while true; do
      printf "What is your full name (ie. Dade Murphy)? "
      read -r name

      if [[ ${name} =~ [^[:space:]]+ ]]; then
        break
      else
        printf "Please enter at least your first name\n\n"
      fi
    done
  fi

  YOUR_NAME="${name}"
}

ask_for_email() {
  _info "ASKING FOR YOUR EMAIL TO CONFIGURE GIT"

  local email=

  set +o errexit
  email="$(git config user.email)"
  set -o errexit

  if [[ -n "${email}" ]]; then
    echo "Skipping, since '${email}' was retrieved from your git config"
  else
    [ -n "${YOUR_EMAIL}" ] &&
      echo "Skipping, since '${YOUR_EMAIL}' was retrieved from your install config" &&
      return 0

    while true; do
      printf "What is your email address (ie. zerocool@example.com)? "
      read -r email

      if [[ ${email} =~ .+@.+ ]]; then
        break
      else
        printf "Please enter a valid email address\n\n"
      fi
    done
  fi

  YOUR_EMAIL="${email}"
}

create_ssh_key() {
  _info "CREATING SSH KEY"

  local -r key_path="${HOME}/.ssh/id_ed25519"

  if [[ -f "${key_path}" ]]; then
    echo "Skipping, since a key already exists at '${key_path}'"
  else
    ssh-keygen -t ed25519 -C "${YOUR_EMAIL}" -N "" -f "${key_path}"
  fi

  _info "SHOWING PUBLIC SSH KEY"

  cat "${key_path}.pub"
}

create_gpg_key() {
  _info "CREATING GPG KEY"

  local gpg_home="${GNUPGHOME}"
  local gpg_key=

  set +o errexit
  gpg_key="$(gpg --export --armor "${YOUR_EMAIL}" 2>/dev/null)"
  set -o errexit

  if [[ "${gpg_key}" =~ "PGP PUBLIC KEY" ]]; then
    echo "Skipping, since a key already exists for '${YOUR_EMAIL}'"
  else
    mkdir -p "${gpg_home}"
    chmod 700 "${gpg_home}"

    while true; do
      printf "Please set a passphrase (password) for your key: "
      read -sr passphrase

      if [[ ! ${passphrase} =~ [^[:space:]]+ ]]; then
        printf "\nPlease enter at least 1 non-space character\n\n"
        continue
      fi

      printf "\n\nPlease confirm your passphrase: "
      read -sr passphrase_confirm

      [ "${passphrase}" = "${passphrase_confirm}" ] && break

      printf "\nYour passphrase did not match, please try again\n\n"
    done

    printf "\n\nGenerating GPG key...\n\n"

    gpg --batch --gen-key <<EOF
     Key-Type: 1
     Key-Length: 3072
     Subkey-Type: 1
     Subkey-Length: 3072
     Name-Real: ${YOUR_NAME}
     Name-Email: ${YOUR_EMAIL}
     Passphrase: ${passphrase}
     Expire-Date: 1y
EOF
  fi

  _info "SHOWING PUBLIC GPG KEY"

  # Delete the last line in a way that works on Linux and macOS.
  gpg --list-keys "${YOUR_EMAIL}" | sed '$d'
}

configure_git() {
  _info "CONFIGURE GIT"

  local git_config_local_path="${DOTFILES_PATH}/.config/git/config.local"

  if [ ! -f "${git_config_local_path}" ]; then
    cat <<EOF >"${git_config_local_path}"
[user]
  name = ${YOUR_NAME}
  email = ${YOUR_EMAIL}

# Uncomment the options below to auto-sign your git commits / tags using GPG.
# Learn more about signing git commits here:
#   https://nickjanetakis.com/blog/signing-and-verifying-git-commits-on-the-command-line-and-github

#[commit]
#  gpgsign = true

# This option requires git 2.23+ to work and you must annotate your tags,
# although -m "" works if you want an empty message.
#[tag]
#  gpgSign = true

[delta]
  # If you prefer side by side diffs, uncomment this.
  #side-by-side = true
EOF
  fi

  echo "It has been configured in '$(dirname "${git_config_local_path}")'"
}

install_programming_languages() {
  _info "INSTALL PROGRAMMING LANGUAGES"

  declare -A mise_languages

  # Merge both arrays.
  for key in "${!MISE_LANGUAGES[@]}"; do
    mise_languages["${key}"]="${MISE_LANGUAGES[${key}]}"
  done
  for key in "${!MISE_LANGUAGES_EXTRAS[@]}"; do
    mise_languages["${key}"]="${MISE_LANGUAGES_EXTRAS[${key}]}"
  done

  if ((${#mise_languages[@]} == 0)); then
    echo "Skipping, since there's no languages set"
    return
  fi

  for key in "${!mise_languages[@]}"; do
    [[ "${key}" = "0" || -z "${mise_languages[${key}]}" ]] && continue

    printf "\nInstalling %s...\n\n" "${mise_languages[${key}]}"
    if command -v "${XDG_DATA_HOME}/mise/shims/${key}" 1>/dev/null; then
      echo "Skipping, it's already installed, run 'mise upgrade ${key} --bump' to upgrade"
    else
      mise use --global "${mise_languages[${key}]}"
    fi

    # Also install Yarn for Node.
    if [ "${key}" = "node" ]; then
      if ! yarn --version >/dev/null 2>&1; then
        npm install --unsafe-perm=true --allow-root --global yarn
      fi
    fi
  done
}

install_tmux_plugins() {
  _info "INSTALL TMUX PLUGINS"

  local plugin_path="${XDG_CONFIG_HOME}/tmux/plugins"
  local tpm_path="${plugin_path}/tpm"

  rm -rf "${tpm_path}"
  git clone --depth 1 https://github.com/tmux-plugins/tpm "${tpm_path}"

  "${tpm_path}/bin/install_plugins"
}

install_nvim_plugins() {
  _info "INSTALL NEOVIM PLUGINS"

  nvim +q

  echo "They've been installed"
}

set_theme() {
  # Default to this theme as a fallback.
  local theme="tokyonight-moon"

  local active_theme=
  local theme_changed=
  local switch_wallpaper=1

  _info "SETTING THEME"

  # Extract the theme name from the symlink path, ie. tokyonight-moon.
  # There are scenarios (first run, etc.) where this will be empty in which
  # case it being undefined is ok.
  if [ -f "${XDG_CONFIG_HOME}/fzf/theme.sh" ]; then
    active_theme="$(readlink "${XDG_CONFIG_HOME}/fzf/theme.sh")"
    active_theme="$(dirname "${active_theme}")"
    active_theme="$(basename "${active_theme##*/}")"
  fi

  # This is when a user runs the install script.
  if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # We don't want to mess with their current theme, but we make sure to
    # check if there's an active theme, if not then it must be the first run.
    if [ -n "${active_theme}" ]; then
      theme="${active_theme}"
      switch_wallpaper=
    fi

  else
    # This is when the dot-theme-set script gets run. Even if a random theme
    # is picked by supplying no argument, $1 is always set from that script.
    theme="${1}"
  fi

  if [ ! -d "${DOTFILES_PATH}/themes/${theme}" ]; then
    echo "Theme '${theme}' not found, aborting!" >&2
    return 1
  fi

  # Did the theme change?
  [[ -n "${active_theme}" && "${active_theme}" != "${theme}" ]] && theme_changed=1

  # Only detect the env if we have to.
  [ -z "${OS_DISTRO:-}" ] && detect_env

  ln -fns "${DOTFILES_PATH}/themes/${theme}/btop.theme" "${XDG_CONFIG_HOME}/btop/themes/theme.theme"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/fzf.sh" "${XDG_CONFIG_HOME}/fzf/theme.sh"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/ghostty" "${XDG_CONFIG_HOME}/ghostty/theme"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/gitui.ron" "${XDG_CONFIG_HOME}/gitui/theme.ron"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/nvim.lua" "${XDG_CONFIG_HOME}/nvim/lua/plugins/theme.lua"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/tmux.conf" "${XDG_CONFIG_HOME}/tmux/theme.conf"

  if [ "${GUI_ENABLED}" == "1" ]; then
    ln -fns "${DOTFILES_PATH}/themes/${theme}/_theme.json" "${XDG_CONFIG_HOME}/wallpaper/theme.json"
    ln -fns "${DOTFILES_PATH}/themes/${theme}/mako" "${XDG_CONFIG_HOME}/mako/theme"
    ln -fns "${DOTFILES_PATH}/themes/${theme}/niri.kdl" "${XDG_CONFIG_HOME}/niri/theme.kdl"
    ln -fns "${DOTFILES_PATH}/themes/${theme}/swaylock" "${XDG_CONFIG_HOME}/swaylock/config"
    ln -fns "${DOTFILES_PATH}/themes/${theme}/walker.css" "${XDG_CONFIG_HOME}/walker/themes/base/theme.css"
    ln -fns "${DOTFILES_PATH}/themes/${theme}/waybar.css" "${XDG_CONFIG_HOME}/waybar/theme.css"

    [ -n "${switch_wallpaper}" ] && "${DOTFILES_PATH}/.local/bin/dot-theme-set-bg"
  fi

  echo "'${theme}' is your active theme"

  # We can abort now since if we're not changing anything there's no reloading.
  [ -z "${theme_changed}" ] && return

  if [ "${OS_IN_WSL}" == "1" ]; then
    local windows_user=

    # shellcheck disable=SC2016
    windows_user="$(powershell.exe '$env:UserName' | tr -d '\r\n')"

    WT_PATH="/mnt/c/Users/${windows_user}/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
    SED_EXPR='s/\("\(colorScheme\|theme\)": *"\)[^"]*"/\1'"${theme}"'"/'

    # Let's make sure the path exists before replacing anything in case someone
    # removed the config entry from CONFIG_INSTALL_WSL.
    [ -e "${WT_PATH}" ] && sed -i "${SED_EXPR}" "${WT_PATH}"
  else
    dot-reload-app ghostty
  fi

  # Reload as many apps as we can.
  dot-reload-app btop
  dot-reload-app tmux

  if [ "${GUI_ENABLED}" == "1" ]; then
    dot-reload-app waybar
    dot-reload-app mako
  fi
}

healthcheck() {
  _info "CHECK INFORMATION AND VERSIONS"

  cat <<EOF
:: Dotfiles path:

${DOTFILES_PATH}

:: Git user:

$(git config --get-regex "user.(name|email)")

:: tmux:

$(tmux -V)

:: Neovim:

$(nvim --version)

:: Fastfetch:

EOF

  fastfetch
}

completed_message() {
  _info "NEXT STEPS (MAKE IT YOUR OWN)"

  cat <<EOF
Check out the README file on GitHub for any next steps:

https://github.com/${DOTFILES_REPO_SLUG}#-make-it-your-own

You can safely close this terminal.

The next time you open your terminal everything will be ready to go!
EOF

  if [[ "${OS_IN_WSL}" == "1" && -f "/tmp/inconsolata.zip" ]]; then
    cat <<EOF

P.S.,

Since you're on WSL 2, please scroll up to the "INSTALL FONTS" section and
follow the few steps there to complete the installation. You only need to do
this once to install a few system fonts.
EOF
  # If there's no Wayland display then it's very likely the first run where
  # nothing graphically has started.
  elif [[ -z "${WAYLAND_DISPLAY:-}" && "${GUI_ENABLED}" == "1" ]]; then
    cat <<EOF

P.S.,

Since you've set GUI_LINUX=1 and this is the first time you've run everything,
you'll want to reboot. After logging in with your user and password then niri
will start by default due to the .zprofile.local file in your dotfiles path.
EOF
  fi
}

parse_args() {
  case "${1:-}" in
  --diff-config | -g)
    # Show a diff of your config file vs the example config file.
    side_by_side="${2:-}"

    [ "${side_by_side}" = "--side" ] && side_by_side="--side-by-side"

    # shellcheck disable=SC2086
    git diff --no-index install-config.example install-config ${side_by_side}

    exit
    ;;
  --diff | -d)
    # Show a diff of any local uncommitted or committed changes vs the target.
    #
    # Since we have fzf, let's use it to make browsing diffs a nice experience!
    target="${2:-"origin/${DOTFILES_BRANCH}"}"
    side_by_side="${3:-}"

    # Since target is optional we need to handle only passing in --side.
    if [ "${target}" = "--side" ]; then
      target="origin/${DOTFILES_BRANCH}"
      side_by_side="--side"
    fi

    git remote | grep -q "${target//./}" && git fetch "${target//./}"

    gd "${target}" "${side_by_side}"

    _info "CONDENSED GIT DIFF"
    GIT_PAGER="" git diff "${target}" --compact-summary

    exit
    ;;
  --new-commits | -n)
    # Show details about new commits that only exist in the target vs local.
    target="${2:-"..origin/${DOTFILES_BRANCH}"}"

    git remote | grep -q "${target//./}" && git fetch --quiet "${target//./}"
    git log "${target}" --pretty="format:%C(magenta)%h %C(green)%ad %C(yellow)> %C(reset)%s" --date=short

    exit
    ;;
  --changelog | -c)
    # Show all remote commits.
    target="${2:-"origin/${DOTFILES_BRANCH}"}"

    git remote | grep -q "${target}" && git fetch --quiet "${target}"
    git log "${target}" --pretty="format:%C(magenta)%h %C(green)%ad %C(yellow)> %C(reset)%s" --date=short

    exit
    ;;
  --local-files | -l)
    # Show local (git ignored) configs, history and scripts.
    {
      fd --type file --unrestricted --extension "local" .
      fd --type file --unrestricted ".local/bin/local"
      echo ".config/zsh/.zsh_history"
      echo "install-config"
    } | sort --unique | fzf --multi --preview='bat --color=always {}' --bind "ctrl-a:toggle-all"

    exit
    ;;
  --pull | -p)
    PULL=1
    ;;
  --update | -u)
    PULL_UPDATE=1
    ;;
  --skip-system-packages | -S)
    SKIP_SYSTEM_PACKAGES=1
    ;;
  --help | -h)
    echo -e "$(
      cat <<EOF
  Usage examples:

  # Run the install script based on the local copy of your dotfiles
  ${C_GREEN}./install${C_RESET}

  # The same as above but skip installing packages (useful for updating symlinks)
  ${C_GREEN}./install --skip-system-packages${C_RESET}

  # Pulls in the latest remote commits and merges them into your local branch,
  # if a BRANCH is supplied a new local branch will be created to be merged into
  # which is helpful for testing PRs without affecting your main branch.
  ${C_GREEN}./install --pull [BRANCH] (it defaults to the currently checked out branch if not supplied)${C_RESET}

  # The same as --pull but also runs the install script afterwards.
  ${C_GREEN}./install --update [BRANCH]${C_RESET}

  # Show a diff of your install-config vs the local install-config.example.
  ${C_GREEN}./install --diff-config${C_RESET}

  # The same as above but show the diff in side-by-side (split) mode.
  ${C_GREEN}./install --diff-config --side${C_RESET}

  # Show a diff of any local uncommited or committed changes vs the remote.
  ${C_GREEN}./install --diff [TARGET]${C_RESET} (it defaults to "origin" if not supplied)

  # The same as above but show the diff in side-by-side (split) mode.
  ${C_GREEN}./install --diff --side${C_RESET}

  # Compare your currently checked out branch to your local ${DOTFILES_BRANCH} branch, this
  # could be helpful if you have a personalized branch and you pull updates into
  # ${DOTFILES_BRANCH} and now you want to compare them locally.
  ${C_GREEN}./install --diff ${DOTFILES_BRANCH}${C_RESET}

  # Show new remote commits that do not exist locally.
  ${C_GREEN}./install --new-commits [TARGET]${C_RESET} (it defaults to "..origin" if not supplied)

  # Show your local commits that don't exist in the remote.
  ${C_GREEN}./install --new-commits origin..${C_RESET}

  # The same as above except compare it to your local ${DOTFILES_BRANCH} branch not remote.
  ${C_GREEN}./install --new-commits ..${DOTFILES_BRANCH}${C_RESET}

  # Show your local commits that don't exist in the remote and new remote commits.
  ${C_GREEN}./install --new-commits origin...${C_RESET}

  # The same as above except compare it to your local ${DOTFILES_BRANCH} branch not remote.
  ${C_GREEN}./install --new-commits ...${DOTFILES_BRANCH}${C_RESET}

  # Show a list of commits on a remote.
  ${C_GREEN}./install --changelog [TARGET] (it defaults to "origin" if not supplied)${C_RESET}

  # Show all of your local files that are git ignored such as configs, history and scripts.
  ${C_GREEN}./install --local-files${C_RESET}

  # Show this help menu.
  ${C_GREEN}./install --help${C_RESET}
EOF
    )"
    exit
    ;;
  *)
    [ -n "${1:-}" ] && _error "'${1}' is not a supported flag"

    ;;
  esac

  return 0
}

# Only run these when calling the script, not sourcing it.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  [[ "${BOOTSTRAP}" == "1" && "${IN_CONTAINER}" != "1" ]] && bootstrap && exit

  parse_args "${@}"
  detect_env
  detect_and_prepare_gpu
  detect_and_prepare_network
  detect_and_prepare_bluetooth
  warn_root
  update_dotfiles "${@}"
  check_install_config

  [ "${PULL}" == "1" ] && exit

  check_prereqs
  create_initial_dirs
  install_packages
  clone_dotfiles
  install_fonts
  install_zsh_plugins
  create_configs
  configure_sudoers_entries
  configure_systemd_services
  configure_system_configs
  configure_home_configs
  configure_home_binaries
  configure_xdg_directories
  configure_shell
  ask_for_name
  ask_for_email
  create_ssh_key
  create_gpg_key
  configure_git
  install_programming_languages
  install_tmux_plugins
  install_nvim_plugins
  set_theme "${@}"
  healthcheck
  completed_message
fi
